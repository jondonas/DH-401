<head>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.3.1.min.js"></script>

    <link rel="stylesheet" href="css/styling.css">
</head>

<title>DH-405</title>
<style>
    body {
        width: 45em;
        margin: 0 auto;
        font-family: Tahoma, Verdana, Arial, sans-serif;
    }
</style>

<body>
    <div>
        <h1>Welcome to Florian and Jonathan's Project!</h1>
        <p>Shortest route between two intersections extracted from an old map of New York.</p>
        <button onclick="clearPaths()">Clear Paths</button>
    </div>
    <div id="mapDiv"></div>

    <script>
        var mapDirectory = "maps/new-york.txt";

        //////////////////////// Dijkstra's Algorithm ////////////////////////

        // Modified from: http://jsfiddle.net/toadskipper/rPhc4/
        function Dijkstra(paths, source, dest) {
            var inf = Number.POSITIVE_INFINITY;
            var distance = {};
            var done = {};
            var pred = {};
            for (var i in paths) {
                distance[i] = inf;
                pred[i] = 0;
                done[i] = false;
            }

            distance[source] = 0;

            for (i in paths) {
                var minDist = inf,
                    closest;
                for (var j in paths) {
                    if (!done[j]) {
                        if (distance[j] <= minDist) {
                            minDist = distance[j];
                            closest = j;
                        }
                    }
                }
                done[closest] = true;
                if (closest === dest) {
                    break;
                }

                var neighbors = pathsFrom(paths, closest);
                for (var nb in neighbors) {
                    var w = neighbors[nb];
                    if (!done[nb]) {
                        if (distance[closest] + w < distance[nb]) {
                            distance[nb] = distance[closest] + w;
                            pred[nb] = closest;
                        }
                    }
                }
            }

            i = dest;
            if (distance[i] < inf) {
                var thePath = [i];
                var node = i;
                while (node !== source) {
                    node = pred[node];
                    thePath.unshift(node);
                }

                return thePath;
            } else {
                return null;
            }
        }

        function makePath(paths, from, to, distance) {
            function addPath(from, to) {
                if (!(from in paths)) {
                    paths[from] = {};
                }
                paths[from][to] = distance;
            }
            addPath(from, to);
            addPath(to, from);
        }

        function pathsFrom(paths, node) {
            var found = paths[node];
            if (found === undefined) {
                console.log("No node named '" + node + "' found.");
            } else {
                return found;
            }
        }

        ////////////////////////// Helper Functions //////////////////////////

        function nodeDistance(n1, n2) {
            var x1 = n1[0];
            var y1 = n1[1];
            var x2 = n2[0];
            var y2 = n2[1];

            // Return the straight-line distance between two points
            return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
        }

        function nameToCoords(name) {
            var coords = name.replace(/^\(|\)$/g, "").split(", ").map(Number);

            return coords;
        }

        function coordsToName(coords) {
            var name = "(" + coords[0] + ", " + coords[1] + ")";

            return name;
        }

        function rotateClockwise(coords) {
            return [coords[1], -coords[0]];
        }

        function matchLine(line) {
            var regEx = /^(.*)\|(.*)$/g;
            var match = regEx.exec(line);
            var left = match[1];
            var right = match[2];

            return [left, right];
        }

        //////////////////////////// Map Creation ////////////////////////////

        var edgesX = [];
        var edgesY = [];
        var nodesX = [];
        var nodesY = [];
        var nodeNames = [];
        var paths = {};

        function getMap() {
            // Read from the map file and initialize graph structures
            $.get({
                url: mapDirectory,
                async: false,
                success: function(txt) {
                    var lines = txt.split("\n");
                    var nodesAdded = {};
                    var edgesAdded = {};

                    for (var i = 0, len = lines.length; i < len; i++) {
                        var line = lines[i];

                        // Skip the file header and/or empty lines
                        if (line.charAt(0) != "(") {
                            continue;
                        }

                        // Match the line to a regex to extract node data
                        var [parentNodeName, numEdges] = matchLine(line);
                        var parentNodeCoords = rotateClockwise(nameToCoords(parentNodeName));
                        numEdges = parseInt(numEdges);

                        if (numEdges > 0) {
                            if (!(parentNodeName in nodesAdded)) {
                                // Dictionary is used for checking-speed, but value is unneeded
                                nodesAdded[parentNodeName] = 0;
                                nodesX.push(parentNodeCoords[0]);
                                nodesY.push(parentNodeCoords[1]);
                                nodeNames.push(parentNodeName);
                            }
                        }

                        // Add edges to the graph
                        for (var ii = 1; ii <= numEdges; ii++) {
                            var [edgeNodeName, meta] = matchLine(lines[i + ii]);
                            var edgeNodeCoords = rotateClockwise(nameToCoords(edgeNodeName));

                            if (!(edgeNodeName in nodesAdded)) {
                                nodesAdded[edgeNodeName] = 0;
                                nodesX.push(edgeNodeCoords[0]);
                                nodesY.push(edgeNodeCoords[1]);
                                nodeNames.push(edgeNodeName);
                            }

                            if (!((parentNodeName + edgeNodeName) in edgesAdded) && !((edgeNodeName + parentNodeName) in edgesAdded)) {
                                edgesAdded[parentNodeName + edgeNodeName] = 0;
                                edgesX.push(parentNodeCoords[0], edgeNodeCoords[0], null);
                                edgesY.push(parentNodeCoords[1], edgeNodeCoords[1], null);
                                makePath(paths, coordsToName(parentNodeCoords), coordsToName(edgeNodeCoords), nodeDistance(parentNodeCoords, edgeNodeCoords));
                            }
                        }
                        i += numEdges;
                    }
                }
            });
        }

        getMap();

        /////////////////////////////// Plotly ///////////////////////////////

        // Plot the edges
        var edgeTrace = {
            x: edgesX,
            y: edgesY,
            line: {
                width: 1,
                color: '#888'
            },
            hoverinfo: 'none',
            mode: 'lines'
        };

        // Plot the nodes
        var nodeTrace = {
            x: nodesX,
            y: nodesY,
            text: nodeNames,
            mode: 'markers',
            hoverinfo: 'text',
            marker: {
                color: 'black',
                size: 5
            }
        };

        var myPlot = document.getElementById('mapDiv');
        var data = [edgeTrace, nodeTrace];

        var layout = {
            showlegend: false,
            hovermode: 'closest',
            margin: {
                b: 0,
                l: 0,
                r: 0,
                t: 0
            },
            xaxis: {
                showgrid: false,
                zeroline: false,
                showticklabels: false,
                fixedrange: true
            },
            yaxis: {
                showgrid: false,
                zeroline: false,
                showticklabels: false,
                fixedrange: true
            }
        };

        Plotly.newPlot('mapDiv', data, layout, {
            displayModeBar: false
        });

        // Keep track of extra traces that are displayed
        var lastNodeName = null;
        var nodesDrawnX = [];
        var nodesDrawnY = [];
        var tracesAdded = 0;

        // Action for when a node is clicked on
        myPlot.on('plotly_click', function(data) {
            var x = data.points[0].x;
            var y = data.points[0].y;
            var nodeName = coordsToName([x, y]);

            var newNodeTrace = {
                x: [],
                y: [],
                mode: 'markers',
                hoverinfo: 'none',
                marker: {
                    color: 'blue',
                    size: 15
                }
            };

            if (lastNodeName == null) {
                // Draw the starting node
                newNodeTrace.x = [x];
                newNodeTrace.y = [y]
                nodesDrawnX = [x];
                nodesDrawnY = [y];
                Plotly.addTraces('mapDiv', newNodeTrace)
            } else {
                // Draw the path to the next node
                var path = Dijkstra(paths, lastNodeName, nodeName);
                var Xs = [];
                var Ys = [];
                for (var i = 0; i + 1 < path.length; i++) {
                    var startCoords = nameToCoords(path[i]);
                    var endCoords = nameToCoords(path[i + 1]);
                    Xs.push(startCoords[0], endCoords[0], null);
                    Ys.push(startCoords[1], endCoords[1], null);
                }

                var newEdgeTrace = {
                    x: Xs,
                    y: Ys,
                    line: {
                        width: 5,
                        color: 'red'
                    },
                    hoverinfo: 'none',
                    mode: 'lines'
                };

                Plotly.addTraces('mapDiv', newEdgeTrace)

                // Remove the trace that draws endpoint nodes, then re-add so it appears on top
                var endNodeCoords = nameToCoords(path[path.length - 1]);
                nodesDrawnX.push(endNodeCoords[0]);
                nodesDrawnY.push(endNodeCoords[1]);
                newNodeTrace.x = nodesDrawnX;
                newNodeTrace.y = nodesDrawnY;

                Plotly.deleteTraces('mapDiv', -2);
                Plotly.addTraces('mapDiv', newNodeTrace);
            }

            lastNodeName = nodeName;
            tracesAdded++;
        });

        // Action to clear the map
        function clearPaths() {
            if (tracesAdded == 0) {
                return;
            }

            var tracesToDelete = [];
            for (var i = 0 - tracesAdded; i < 0; i++) {
                tracesToDelete.push(i);
            }

            Plotly.deleteTraces('mapDiv', tracesToDelete);
            lastNodeName = null;
            nodesDrawnX = [];
            nodesDrawnY = [];
            tracesAdded = 0;
        }
    </script>
</body>