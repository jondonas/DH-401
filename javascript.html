<head>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.3.1.min.js"></script>

    <link rel="stylesheet" href="css/styling.css">
</head>

<title>DH-405</title>
<style>
    body {
        width: 45em;
        margin: 0 auto;
        font-family: Tahoma, Verdana, Arial, sans-serif;
    }
</style>

<body>
    <div>
        <h1>Welcome to Florian and Jonathan's Project!</h1>
        <p>Shortest route between two intersections extracted from an old map of New York.</p>
        <button onclick="clearPaths()">Clear Paths</button>
    </div>
    <div id="mapDiv"></div>

    <script>
        var mapDirectory = "maps/new-york.txt";

        //////////////////////// Dijkstra's Algorithm ////////////////////////

        // Modified from: http://jsfiddle.net/toadskipper/rPhc4/
        function Dijkstra(roads, source, dest) {
            var inf = Number.POSITIVE_INFINITY;
            var distance = {};
            var done = {};
            var pred = {};
            for (var i in roads) {
                distance[i] = inf;
                pred[i] = 0;
                done[i] = false;
            }

            distance[source] = 0;

            for (i in roads) {
                var minDist = inf,
                    closest;
                for (var j in roads) {
                    if (!done[j]) {
                        if (distance[j] <= minDist) {
                            minDist = distance[j];
                            closest = j;
                        }
                    }
                }
                done[closest] = true;
                if (closest === dest) {
                    break;
                }

                var neighbors = roadsFrom(closest);
                for (var nb in neighbors) {
                    var w = neighbors[nb];
                    if (!done[nb]) {
                        if (distance[closest] + w < distance[nb]) {
                            distance[nb] = distance[closest] + w;
                            pred[nb] = closest;
                        }
                    }
                }
            }

            i = dest;
            if (distance[i] < inf) {
                var thePath = i;
                var place = i;
                while (place !== source) {
                    place = pred[place];
                    if (place !== source) {
                        thePath = place + '->' + thePath;
                    }
                }
                thePath = place + '->' + thePath;
                console.log("Distance from " + source + "-->" + dest + " : " +
                    distance[i] + ' (' + thePath + ')' + '<br/>');
            } else {
                $('#out').append("no path" + '<br/>');
            }
        }

        var roads = {};

        function makeRoad(from, to, length) {
            function addRoad(from, to) {
                if (!(from in roads)) {
                    roads[from] = {};
                }
                roads[from][to] = length;
            }
            addRoad(from, to);
            addRoad(to, from);
        }

        function makeRoads(start) {
            for (var i = 1; i < arguments.length; i += 2) {
                makeRoad(start, arguments[i], arguments[i + 1]);
            }
        }

        function roadsFrom(place) {
            var found = roads[place];
            if (found === undefined) {
                print("No place named '" + place + "' found.");
            } else {
                return found;
            }
        }

        makeRoads("A", "B", 2, "C", 3);
        //Dijkstra(roads, "A", "F");

        ////////////////////////// Helper Functions //////////////////////////

        function nodeDistance(n1, n2) {
            var x1 = n1[0];
            var y1 = n1[1];
            var x2 = n2[0];
            var y2 = n2[1];

            // Return the straight-line distance between two points
            return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
        }

        function parseTuple(t) {
            var tuple = t.replace(/^\(|\)$/g, "").split(",").map(Number);

            return tuple;
        }

        function matchLine(line) {
            var regEx = /^(.*)\|(.*)$/g;
            var match = regEx.exec(line);
            var left = match[1];
            var right = match[2];
            var coords = parseTuple(left);
            coords = [coords[1], -coords[0]];

            return [left, coords, right];
        }

        //////////////////////////// Map Creation ////////////////////////////

        var edgesX = [];
        var edgesY = [];
        var nodesX = [];
        var nodesY = [];
        var nodeNames = [];

        function getMap() {
            // Read from the map file and initialize graph structures
            $.get({
                url: mapDirectory,
                async: false,
                success: function(txt) {
                    var lines = txt.split("\n");
                    var nodesAdded = {};
                    var edgesAdded = {};

                    for (var i = 0, len = lines.length; i < len; i++) {
                        var line = lines[i];

                        // Skip the file header and/or empty lines
                        if (line.charAt(0) != "(") {
                            continue;
                        }

                        // Match the line to a regex to extract node data
                        var [parentNode, parentNodeCoords, numEdges] = matchLine(line);
                        numEdges = parseInt(numEdges);
                        if (numEdges != 0) {
                            if (!(parentNode in nodesAdded)) {
                                // Dictionary is used for checking-speed, but value is unneeded
                                nodesAdded[parentNode] = 0;
                                nodesX.push(parentNodeCoords[0]);
                                nodesY.push(parentNodeCoords[1]);
                                nodeNames.push(parentNode);
                            }
                        }

                        // Add edges to the graph
                        for (var ii = 1; ii <= numEdges; ii++) {
                            var [edgeNode, edgeNodeCoords, meta] = matchLine(lines[i + ii]);
                            if (!(edgeNode in nodesAdded)) {
                                nodesAdded[edgeNode] = 0;
                                nodesX.push(edgeNodeCoords[0]);
                                nodesY.push(edgeNodeCoords[1]);
                                nodeNames.push(edgeNode);
                            }

                            if (!((parentNode + edgeNode) in edgesAdded) && !((edgeNode + parentNode) in edgesAdded)) {
                                edgesAdded[parentNode + edgeNode] = 0;
                                edgesX.push(parentNodeCoords[0], edgeNodeCoords[0], null);
                                edgesY.push(parentNodeCoords[1], edgeNodeCoords[1], null);
                            }

                            //// TODO Dijkstra

                        }
                        i += numEdges;
                    }
                }
            });
        }

        getMap();

        /////////////////////////////// Plotly ///////////////////////////////

        // Plot the edges
        var edgeTrace = {
            x: edgesX,
            y: edgesY,
            type: 'scatter',
            line: {
                width: 1,
                color: '#888'
            },
            hoverinfo: 'none',
            mode: 'lines'
        };

        // Plot the nodes
        var nodeTrace = {
            x: nodesX,
            y: nodesY,
            text: nodeNames,
            mode: 'markers',
            hoverinfo: 'text',
            marker: {
                color: 'black',
                size: 5
            }
        };

        var myPlot = document.getElementById('mapDiv');
        var data = [edgeTrace, nodeTrace];

        var layout = {
            showlegend: false,
            hovermode: 'closest',
            margin: {
                b: 0,
                l: 0,
                r: 0,
                t: 0
            },
            xaxis: {
                showgrid: false,
                zeroline: false,
                showticklabels: false,
                fixedrange: true
            },
            yaxis: {
                showgrid: false,
                zeroline: false,
                showticklabels: false,
                fixedrange: true
            }
        };

        Plotly.newPlot('mapDiv', data, layout, {
            displayModeBar: false
        });

        // Keep track of extra traces that are displayed
        var lastTrace = null;
        var tracesAdded = 0;

        // Action for when a node is clicked on
        myPlot.on('plotly_click', function(data) {
            var x = data.points[0].x;
            var y = data.points[0].y;

            if (lastTrace == null) {
                // Draw the starting node
                lastTrace = {
                    x: [x],
                    y: [y],
                    mode: 'markers',
                    hoverinfo: 'none',
                    marker: {
                        color: 'blue',
                        size: 15
                    }
                };
            } else {
                // Draw the path to the next node
                lastTrace = {
                    x: [x],
                    y: [y],
                    mode: 'markers',
                    hoverinfo: 'none',
                    marker: {
                        color: 'blue',
                        size: 15
                    }
                };
            }

            tracesAdded++;
            Plotly.addTraces('mapDiv', lastTrace)
        });

        // Action to clear the map
        function clearPaths() {
            if (tracesAdded == 0) {
                return;
            }

            var tracesToDelete = [];
            for (var i = 0 - tracesAdded; i < 0; i++) {
                tracesToDelete.push(i);
            }

            Plotly.deleteTraces('mapDiv', tracesToDelete);
            lastTrace = null;
            tracesAdded = 0;
        }
    </script>
</body>